{"version":3,"file":"monitoring-e5309bcb.js","sources":["../../src/services/PerformanceMonitoring.ts","../../src/hooks/useFederatedModule.ts"],"sourcesContent":["// Performance Monitoring for Federated Independence Architecture\n// Real-time metrics to ensure <2s load times and 99.9% uptime\n// File: src/services/PerformanceMonitoring.ts\n\nimport { serviceDiscovery } from './OptionalServiceDiscovery';\nimport { connectionManager } from './FederatedConnectionManager';\n\ninterface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: string;\n  timestamp: Date;\n  threshold?: number;\n  status: 'good' | 'warning' | 'critical';\n}\n\ninterface PageLoadMetric {\n  page: string;\n  loadTime: number;\n  contentLoadTime: number;\n  servicesUsed: string[];\n  fallbacksUsed: string[];\n  timestamp: Date;\n}\n\ninterface ServiceMetric {\n  serviceName: string;\n  responseTime: number;\n  availability: number;\n  errorRate: number;\n  circuitBreakerState: string;\n  timestamp: Date;\n}\n\nexport class PerformanceMonitoring {\n  private metrics: PerformanceMetric[] = [];\n  private pageLoadMetrics: PageLoadMetric[] = [];\n  private serviceMetrics: ServiceMetric[] = [];\n  private maxMetricsHistory = 1000;\n  private alertThresholds = {\n    pageLoadTime: 2000, // 2 seconds\n    serviceResponseTime: 1000, // 1 second\n    availability: 0.999, // 99.9%\n    errorRate: 0.01 // 1%\n  };\n\n  constructor() {\n    this.startPerformanceCollection();\n  }\n\n  private startPerformanceCollection(): void {\n    // Collect metrics every 10 seconds\n    setInterval(() => {\n      this.collectSystemMetrics();\n      this.collectServiceMetrics();\n    }, 10000);\n\n    // Clean up old metrics every 5 minutes\n    setInterval(() => {\n      this.cleanupOldMetrics();\n    }, 5 * 60 * 1000);\n  }\n\n  // Track page load performance\n  trackPageLoad(\n    page: string,\n    startTime: number,\n    servicesUsed: string[] = [],\n    fallbacksUsed: string[] = []\n  ): void {\n    const loadTime = Date.now() - startTime;\n    const contentLoadTime = this.measureContentLoadTime();\n\n    const metric: PageLoadMetric = {\n      page,\n      loadTime,\n      contentLoadTime,\n      servicesUsed,\n      fallbacksUsed,\n      timestamp: new Date()\n    };\n\n    this.pageLoadMetrics.push(metric);\n    \n    // Add performance metric\n    this.addMetric({\n      name: `page_load_${page}`,\n      value: loadTime,\n      unit: 'ms',\n      timestamp: new Date(),\n      threshold: this.alertThresholds.pageLoadTime,\n      status: loadTime < this.alertThresholds.pageLoadTime ? 'good' : \n              loadTime < this.alertThresholds.pageLoadTime * 1.5 ? 'warning' : 'critical'\n    });\n\n    // Alert if load time exceeds threshold\n    if (loadTime > this.alertThresholds.pageLoadTime) {\n      console.warn(`Page load time exceeded threshold: ${page} took ${loadTime}ms`);\n      this.triggerAlert('page_load_slow', {\n        page,\n        loadTime,\n        threshold: this.alertThresholds.pageLoadTime\n      });\n    }\n  }\n\n  private measureContentLoadTime(): number {\n    if (typeof window !== 'undefined' && window.performance) {\n      const navigation = window.performance.getEntriesByType('navigation')[0] as any;\n      if (navigation) {\n        return navigation.loadEventEnd - navigation.loadEventStart;\n      }\n    }\n    return 0;\n  }\n\n  // Track feature execution performance\n  trackFeatureExecution(\n    featureName: string,\n    executionTime: number,\n    success: boolean,\n    enhanced: boolean,\n    servicesUsed: string[] = []\n  ): void {\n    const metric: PerformanceMetric = {\n      name: `feature_${featureName}`,\n      value: executionTime,\n      unit: 'ms',\n      timestamp: new Date(),\n      status: success ? (executionTime < 500 ? 'good' : 'warning') : 'critical'\n    };\n\n    this.addMetric(metric);\n\n    // Track enhancement success rate\n    if (servicesUsed.length > 0) {\n      this.addMetric({\n        name: `enhancement_${featureName}`,\n        value: enhanced ? 1 : 0,\n        unit: 'boolean',\n        timestamp: new Date(),\n        status: enhanced ? 'good' : 'warning'\n      });\n    }\n  }\n\n  private collectSystemMetrics(): void {\n    // Memory usage\n    if (typeof performance !== 'undefined' && (performance as any).memory) {\n      const memory = (performance as any).memory;\n      this.addMetric({\n        name: 'memory_used',\n        value: memory.usedJSHeapSize / 1024 / 1024,\n        unit: 'MB',\n        timestamp: new Date(),\n        status: memory.usedJSHeapSize / memory.jsHeapSizeLimit < 0.8 ? 'good' : 'warning'\n      });\n    }\n\n    // Connection count\n    const connectionStats = connectionManager.getConnectionStats();\n    const totalConnections = Object.values(connectionStats)\n      .reduce((total, stat: any) => total + stat.activeConnections, 0);\n    \n    this.addMetric({\n      name: 'active_connections',\n      value: totalConnections,\n      unit: 'count',\n      timestamp: new Date(),\n      status: totalConnections < 10 ? 'good' : 'warning'\n    });\n  }\n\n  private async collectServiceMetrics(): Promise<void> {\n    const services = serviceDiscovery.getAllServices();\n    \n    for (const service of services) {\n      try {\n        const startTime = Date.now();\n        const isAvailable = await serviceDiscovery.isServiceAvailable(service.name);\n        const responseTime = Date.now() - startTime;\n        \n        const circuitBreakerState = serviceDiscovery.getCircuitBreakerState(service.name);\n        \n        const serviceMetric: ServiceMetric = {\n          serviceName: service.name,\n          responseTime,\n          availability: isAvailable ? 1 : 0,\n          errorRate: circuitBreakerState === 'open' ? 1 : 0,\n          circuitBreakerState,\n          timestamp: new Date()\n        };\n\n        this.serviceMetrics.push(serviceMetric);\n\n        // Add individual metrics\n        this.addMetric({\n          name: `service_response_${service.name}`,\n          value: responseTime,\n          unit: 'ms',\n          timestamp: new Date(),\n          threshold: this.alertThresholds.serviceResponseTime,\n          status: responseTime < this.alertThresholds.serviceResponseTime ? 'good' : 'warning'\n        });\n\n        this.addMetric({\n          name: `service_availability_${service.name}`,\n          value: isAvailable ? 1 : 0,\n          unit: 'boolean',\n          timestamp: new Date(),\n          status: isAvailable ? 'good' : 'critical'\n        });\n\n      } catch (error) {\n        console.error(`Failed to collect metrics for ${service.name}:`, error);\n      }\n    }\n  }\n\n  private addMetric(metric: PerformanceMetric): void {\n    this.metrics.push(metric);\n    \n    // Limit history size\n    if (this.metrics.length > this.maxMetricsHistory) {\n      this.metrics = this.metrics.slice(-this.maxMetricsHistory);\n    }\n  }\n\n  private cleanupOldMetrics(): void {\n    const cutoffTime = new Date(Date.now() - 60 * 60 * 1000); // 1 hour ago\n    \n    this.metrics = this.metrics.filter(m => m.timestamp > cutoffTime);\n    this.pageLoadMetrics = this.pageLoadMetrics.filter(m => m.timestamp > cutoffTime);\n    this.serviceMetrics = this.serviceMetrics.filter(m => m.timestamp > cutoffTime);\n  }\n\n  private triggerAlert(type: string, data: any): void {\n    const alert = {\n      type,\n      data,\n      timestamp: new Date(),\n      severity: this.getAlertSeverity(type)\n    };\n\n    console.warn('Performance Alert:', alert);\n    \n    // In production, this would send to monitoring service\n    // await this.sendToMonitoringService(alert);\n  }\n\n  private getAlertSeverity(type: string): 'low' | 'medium' | 'high' | 'critical' {\n    switch (type) {\n      case 'page_load_slow': return 'high';\n      case 'service_unavailable': return 'medium';\n      case 'memory_high': return 'medium';\n      case 'error_rate_high': return 'high';\n      default: return 'low';\n    }\n  }\n\n  // Public API for getting metrics\n  getCurrentMetrics(): Record<string, any> {\n    const now = new Date();\n    const last5Minutes = new Date(now.getTime() - 5 * 60 * 1000);\n    \n    const recentMetrics = this.metrics.filter(m => m.timestamp > last5Minutes);\n    \n    return {\n      timestamp: now.toISOString(),\n      platform: {\n        averagePageLoadTime: this.getAveragePageLoadTime(),\n        systemHealth: this.getSystemHealthScore(),\n        serviceAvailability: this.getServiceAvailability(),\n        independenceRatio: this.getIndependenceRatio()\n      },\n      services: this.getServiceSummary(),\n      performance: {\n        pageLoads: this.pageLoadMetrics.slice(-10),\n        recentMetrics: recentMetrics.slice(-20)\n      }\n    };\n  }\n\n  private getAveragePageLoadTime(): number {\n    const recentLoads = this.pageLoadMetrics.slice(-10);\n    if (recentLoads.length === 0) return 0;\n    \n    const total = recentLoads.reduce((sum, load) => sum + load.loadTime, 0);\n    return Math.round(total / recentLoads.length);\n  }\n\n  private getSystemHealthScore(): number {\n    const recentMetrics = this.metrics.filter(\n      m => m.timestamp > new Date(Date.now() - 5 * 60 * 1000)\n    );\n    \n    if (recentMetrics.length === 0) return 1;\n    \n    const goodMetrics = recentMetrics.filter(m => m.status === 'good').length;\n    return Math.round((goodMetrics / recentMetrics.length) * 100) / 100;\n  }\n\n  private getServiceAvailability(): Record<string, number> {\n    const availability: Record<string, number> = {};\n    const services = serviceDiscovery.getAllServices();\n    \n    for (const service of services) {\n      const recentMetrics = this.serviceMetrics\n        .filter(m => m.serviceName === service.name)\n        .slice(-10);\n        \n      if (recentMetrics.length > 0) {\n        const availableCount = recentMetrics.filter(m => m.availability === 1).length;\n        availability[service.name] = Math.round((availableCount / recentMetrics.length) * 100) / 100;\n      } else {\n        availability[service.name] = 0;\n      }\n    }\n    \n    return availability;\n  }\n\n  private getIndependenceRatio(): number {\n    const recentLoads = this.pageLoadMetrics.slice(-20);\n    if (recentLoads.length === 0) return 1;\n    \n    const independentLoads = recentLoads.filter(load => \n      load.servicesUsed.length === 0 || load.fallbacksUsed.length > 0\n    ).length;\n    \n    return Math.round((independentLoads / recentLoads.length) * 100) / 100;\n  }\n\n  private getServiceSummary(): Record<string, any> {\n    const summary: Record<string, any> = {};\n    const services = serviceDiscovery.getAllServices();\n    \n    for (const service of services) {\n      const recentMetrics = this.serviceMetrics\n        .filter(m => m.serviceName === service.name)\n        .slice(-10);\n        \n      if (recentMetrics.length > 0) {\n        const avgResponseTime = recentMetrics.reduce((sum, m) => sum + m.responseTime, 0) / recentMetrics.length;\n        const availability = recentMetrics.filter(m => m.availability === 1).length / recentMetrics.length;\n        const circuitBreakerState = recentMetrics[recentMetrics.length - 1].circuitBreakerState;\n        \n        summary[service.name] = {\n          averageResponseTime: Math.round(avgResponseTime),\n          availability: Math.round(availability * 100) / 100,\n          circuitBreakerState,\n          lastChecked: recentMetrics[recentMetrics.length - 1].timestamp\n        };\n      } else {\n        summary[service.name] = {\n          averageResponseTime: null,\n          availability: 0,\n          circuitBreakerState: 'unknown',\n          lastChecked: null\n        };\n      }\n    }\n    \n    return summary;\n  }\n\n  // Performance testing utilities\n  async runPerformanceTest(): Promise<any> {\n    console.log('Running performance test...');\n    \n    const testResults = {\n      pageLoadTimes: [],\n      serviceResponseTimes: [],\n      independenceTest: null as any,\n      timestamp: new Date().toISOString()\n    };\n\n    // Test page load times (simulate)\n    const pages = ['/', '/governance', '/ecosystem', '/moderation'];\n    for (const page of pages) {\n      const startTime = Date.now();\n      // Simulate page load\n      await this.delay(100 + Math.random() * 500);\n      const loadTime = Date.now() - startTime;\n      \n      (testResults.pageLoadTimes as any[]).push({\n        page,\n        loadTime,\n        passesThreshold: loadTime < this.alertThresholds.pageLoadTime\n      });\n    }\n\n    // Test service response times\n    const services = serviceDiscovery.getAllServices();\n    for (const service of services) {\n      try {\n        const startTime = Date.now();\n        const isAvailable = await serviceDiscovery.isServiceAvailable(service.name);\n        const responseTime = Date.now() - startTime;\n        \n        (testResults.serviceResponseTimes as any[]).push({\n          service: service.name,\n          responseTime,\n          available: isAvailable,\n          passesThreshold: responseTime < this.alertThresholds.serviceResponseTime\n        });\n      } catch (error) {\n        (testResults.serviceResponseTimes as any[]).push({\n          service: service.name,\n          responseTime: null,\n          available: false,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n      }\n    }\n\n    // Test independence (simulate all services down)\n    serviceDiscovery.clearHealthCache();\n    const independenceStartTime = Date.now();\n    \n    try {\n      // Test core functionality without external services\n      const coreFeatures = ['governance', 'moderation', 'content_submission'];\n      const independenceResults = [];\n      \n      for (const feature of coreFeatures) {\n        const featureStartTime = Date.now();\n        // Simulate feature execution\n        await this.delay(50 + Math.random() * 200);\n        const executionTime = Date.now() - featureStartTime;\n        \n        independenceResults.push({\n          feature,\n          executionTime,\n          success: true,\n          workingIndependently: true\n        });\n      }\n      \n      testResults.independenceTest = {\n        totalTime: Date.now() - independenceStartTime,\n        features: independenceResults,\n        allFeaturesWorking: independenceResults.every(f => f.success),\n        averageExecutionTime: independenceResults.reduce((sum, f) => sum + f.executionTime, 0) / independenceResults.length\n      };\n      \n    } catch (error) {\n      testResults.independenceTest = {\n        error: error instanceof Error ? error.message : 'Independence test failed',\n        success: false\n      };\n    }\n\n    console.log('Performance test completed:', testResults);\n    return testResults;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Health check endpoint for monitoring\n  getHealthCheck(): any {\n    const metrics = this.getCurrentMetrics();\n    \n    return {\n      status: metrics.platform.systemHealth > 0.8 ? 'healthy' : 'degraded',\n      timestamp: new Date().toISOString(),\n      platform: {\n        systemHealth: metrics.platform.systemHealth,\n        averagePageLoadTime: metrics.platform.averagePageLoadTime,\n        independenceRatio: metrics.platform.independenceRatio\n      },\n      services: metrics.services,\n      alerts: this.getActiveAlerts()\n    };\n  }\n\n  private getActiveAlerts(): any[] {\n    // Return any active performance alerts\n    // This would be implemented based on specific monitoring needs\n    return [];\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitoring();","// Custom Hook for Federated Independence Architecture\n// Provides easy integration of optional services with graceful fallback\n// File: src/hooks/useFederatedModule.ts\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { blkoutModule } from '../services/IndependentModuleCore';\nimport { performanceMonitor } from '../services/PerformanceMonitoring';\nimport { serviceDiscovery } from '../services/OptionalServiceDiscovery';\n\ninterface FederatedState<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n  enhanced: boolean;\n  servicesUsed: string[];\n  fallbacksUsed: string[];\n  responseTime: number;\n}\n\ninterface UseFederatedModuleOptions {\n  feature: string;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n  trackPerformance?: boolean;\n}\n\nexport function useFederatedModule<T>(\n  options: UseFederatedModuleOptions\n): {\n  state: FederatedState<T>;\n  execute: (parameters: any) => Promise<void>;\n  refresh: () => Promise<void>;\n  isIndependent: boolean;\n  serviceStatuses: Record<string, boolean>;\n} {\n  const [state, setState] = useState<FederatedState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n    enhanced: false,\n    servicesUsed: [],\n    fallbacksUsed: [],\n    responseTime: 0\n  });\n\n  const [serviceStatuses, setServiceStatuses] = useState<Record<string, boolean>>({});\n  const [isIndependent, setIsIndependent] = useState(true);\n\n  const execute = useCallback(async (parameters: any) => {\n    const startTime = Date.now();\n    \n    setState(prev => ({ ...prev, loading: true, error: null }));\n\n    try {\n      const result = await blkoutModule.executeFeature<T>(\n        options.feature,\n        parameters,\n        {\n          timeout: 2000,\n          retries: 1,\n          fallbackValue: null\n        }\n      );\n\n      const responseTime = Date.now() - startTime;\n\n      if (result.success) {\n        setState({\n          data: result.data || null,\n          loading: false,\n          error: null,\n          enhanced: result.enhanced || false,\n          servicesUsed: result.servicesUsed || [],\n          fallbacksUsed: result.fallbacksUsed || [],\n          responseTime\n        });\n\n        // Track performance if enabled\n        if (options.trackPerformance) {\n          performanceMonitor.trackFeatureExecution(\n            options.feature,\n            responseTime,\n            true,\n            result.enhanced || false,\n            result.servicesUsed || []\n          );\n        }\n\n      } else {\n        setState(prev => ({\n          ...prev,\n          loading: false,\n          error: result.error || 'Feature execution failed',\n          responseTime\n        }));\n\n        // Track failed execution\n        if (options.trackPerformance) {\n          performanceMonitor.trackFeatureExecution(\n            options.feature,\n            responseTime,\n            false,\n            false,\n            []\n          );\n        }\n      }\n\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      \n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: errorMessage,\n        responseTime\n      }));\n\n      // Track error\n      if (options.trackPerformance) {\n        performanceMonitor.trackFeatureExecution(\n          options.feature,\n          responseTime,\n          false,\n          false,\n          []\n        );\n      }\n    }\n  }, [options.feature, options.trackPerformance]);\n\n  const refresh = useCallback(() => execute({}), [execute]);\n\n  const checkServiceStatuses = useCallback(async () => {\n    try {\n      const services = serviceDiscovery.getAllServices();\n      const statuses: Record<string, boolean> = {};\n      \n      for (const service of services) {\n        statuses[service.name] = await serviceDiscovery.isServiceAvailable(service.name);\n      }\n      \n      setServiceStatuses(statuses);\n      \n      // Determine if we're running independently\n      const anyServiceAvailable = Object.values(statuses).some(status => status);\n      setIsIndependent(!anyServiceAvailable);\n      \n    } catch (error) {\n      console.error('Failed to check service statuses:', error);\n      setIsIndependent(true); // Default to independent mode\n    }\n  }, []);\n\n  useEffect(() => {\n    // Initial service status check\n    checkServiceStatuses();\n    \n    // Set up auto-refresh if enabled\n    if (options.autoRefresh) {\n      const interval = setInterval(() => {\n        checkServiceStatuses();\n        refresh();\n      }, options.refreshInterval || 30000);\n\n      return () => clearInterval(interval);\n    }\n  }, [options.autoRefresh, options.refreshInterval, refresh, checkServiceStatuses]);\n\n  return {\n    state,\n    execute,\n    refresh,\n    isIndependent,\n    serviceStatuses\n  };\n}\n\nexport function useServiceHealth() {\n  const [services, setServices] = useState<any[]>([]);\n  const [overallHealth, setOverallHealth] = useState(0);\n  const [loading, setLoading] = useState(true);\n\n  const checkHealth = useCallback(async () => {\n    setLoading(true);\n    try {\n      const allServices = serviceDiscovery.getAllServices();\n      const healthResults = await Promise.all(\n        allServices.map(async (service) => {\n          try {\n            const isAvailable = await serviceDiscovery.isServiceAvailable(service.name);\n            const health = serviceDiscovery.getServiceHealth(service.name);\n            const circuitBreakerState = serviceDiscovery.getCircuitBreakerState(service.name);\n            \n            return {\n              name: service.name,\n              available: isAvailable,\n              responseTime: health?.responseTime || null,\n              status: health?.status || 'unknown',\n              circuitBreakerState,\n              capabilities: service.capabilities,\n              lastChecked: health?.lastChecked || new Date()\n            };\n          } catch (error) {\n            return {\n              name: service.name,\n              available: false,\n              error: error instanceof Error ? error.message : 'Unknown error',\n              circuitBreakerState: 'unknown',\n              capabilities: service.capabilities,\n              lastChecked: new Date()\n            };\n          }\n        })\n      );\n\n      setServices(healthResults);\n      \n      // Calculate overall health score\n      const availableServices = healthResults.filter(s => s.available).length;\n      const healthScore = availableServices / healthResults.length;\n      setOverallHealth(healthScore);\n      \n    } catch (error) {\n      console.error('Health check failed:', error);\n      setServices([]);\n      setOverallHealth(0);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    checkHealth();\n    \n    // Check health every 30 seconds\n    const interval = setInterval(checkHealth, 30000);\n    return () => clearInterval(interval);\n  }, [checkHealth]);\n\n  return {\n    services,\n    overallHealth,\n    loading,\n    refresh: checkHealth\n  };\n}\n\nexport function usePerformanceMetrics() {\n  const [metrics, setMetrics] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n\n  const loadMetrics = useCallback(() => {\n    try {\n      const currentMetrics = performanceMonitor.getCurrentMetrics();\n      setMetrics(currentMetrics);\n    } catch (error) {\n      console.error('Failed to load performance metrics:', error);\n      setMetrics(null);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const runPerformanceTest = useCallback(async () => {\n    setLoading(true);\n    try {\n      const testResults = await performanceMonitor.runPerformanceTest();\n      return testResults;\n    } catch (error) {\n      console.error('Performance test failed:', error);\n      throw error;\n    } finally {\n      setLoading(false);\n      loadMetrics();\n    }\n  }, [loadMetrics]);\n\n  useEffect(() => {\n    loadMetrics();\n    \n    // Refresh metrics every 10 seconds\n    const interval = setInterval(loadMetrics, 10000);\n    return () => clearInterval(interval);\n  }, [loadMetrics]);\n\n  return {\n    metrics,\n    loading,\n    refresh: loadMetrics,\n    runPerformanceTest\n  };\n}"],"names":["performanceMonitor","constructor","__publicField","this","pageLoadTime","serviceResponseTime","availability","errorRate","startPerformanceCollection","setInterval","collectSystemMetrics","collectServiceMetrics","cleanupOldMetrics","trackPageLoad","page","startTime","servicesUsed","fallbacksUsed","loadTime","Date","now","metric","contentLoadTime","measureContentLoadTime","timestamp","pageLoadMetrics","push","addMetric","name","value","unit","threshold","alertThresholds","status","console","warn","triggerAlert","window","performance","navigation","getEntriesByType","loadEventEnd","loadEventStart","trackFeatureExecution","featureName","executionTime","success","enhanced","length","memory","usedJSHeapSize","jsHeapSizeLimit","connectionStats","connectionManager","getConnectionStats","totalConnections","Object","values","reduce","total","stat","activeConnections","services","serviceDiscovery","getAllServices","service","isAvailable","isServiceAvailable","responseTime","circuitBreakerState","getCircuitBreakerState","serviceMetric","serviceName","serviceMetrics","error","metrics","maxMetricsHistory","slice","cutoffTime","filter","m","type","data","alert","severity","getAlertSeverity","getCurrentMetrics","last5Minutes","getTime","recentMetrics","toISOString","platform","averagePageLoadTime","getAveragePageLoadTime","systemHealth","getSystemHealthScore","serviceAvailability","getServiceAvailability","independenceRatio","getIndependenceRatio","getServiceSummary","pageLoads","recentLoads","sum","load","Math","round","goodMetrics","availableCount","independentLoads","summary","avgResponseTime","averageResponseTime","lastChecked","runPerformanceTest","log","testResults","pageLoadTimes","serviceResponseTimes","independenceTest","pages","delay","random","passesThreshold","available","Error","message","clearHealthCache","independenceStartTime","coreFeatures","independenceResults","feature","featureStartTime","workingIndependently","totalTime","features","allFeaturesWorking","every","f","averageExecutionTime","ms","Promise","resolve","setTimeout","getHealthCheck","alerts","getActiveAlerts","useServiceHealth","setServices","useState","overallHealth","setOverallHealth","loading","setLoading","checkHealth","useCallback","async","allServices","healthResults","all","map","health","getServiceHealth","capabilities","healthScore","s","useEffect","interval","clearInterval","refresh","usePerformanceMetrics","setMetrics","loadMetrics","currentMetrics"],"mappings":"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"}